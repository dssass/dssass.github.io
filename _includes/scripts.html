<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 1. 處理捲動時，目錄項目高亮顯示的邏輯 (這部分不變) ---
  const sections = document.querySelectorAll('h2[id], h3[id], h4[id], h5[id]');
  const tocLinks = document.querySelectorAll('#toc-sidebar a');

  const observer = new IntersectionObserver((entries) => {
    let latestIntersectingId = null;

    entries.forEach(entry => {
        if (entry.isIntersecting) {
            if (!latestIntersectingId) {
                latestIntersectingId = entry.target.getAttribute('id');
            }
        }
    });

    if (latestIntersectingId) {
      tocLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href')) {
          const linkHref = link.getAttribute('href').substring(1);
          if (linkHref === latestIntersectingId) {
            link.classList.add('active');
            const parentSubmenu = link.closest('.submenu');
            if (parentSubmenu && !parentSubmenu.parentElement.classList.contains('open')) {
              parentSubmenu.parentElement.classList.add('open');
            }
          }
        }
      });
    }
  }, {
    rootMargin: '0px 0px -70% 0px'
  });

  sections.forEach(section => {
    observer.observe(section);
  });

  // --- 2. ★★★ 優化後的側邊欄點擊邏輯 ★★★ ---
  // 我們將「展開/收合」和「關閉選單」的邏輯合併在一起，避免衝突
  const sidebar = document.getElementById('toc-sidebar');
  const body = document.body;

  if (sidebar) {
    sidebar.addEventListener('click', (event) => {
      // 找到使用者實際點擊的 <a> 連結元素
      const targetLink = event.target.closest('a');

      // 如果點擊的不是連結，就什麼都不做
      if (!targetLink) {
        return;
      }

      // 情況一：如果點擊的連結是「父層選單」(它帶有 'has-submenu' class)
      if (targetLink.classList.contains('has-submenu')) {
        // 我們要阻止它預設的跳轉行為
        event.preventDefault();
        // 並且只切換它底下子選單的展開/收合狀態
        targetLink.parentElement.classList.toggle('open');
      }
      // 情況二：如果點擊的是一個「普通的頁內連結」(不是父層選單)
      else if (targetLink.getAttribute('href') && targetLink.getAttribute('href').startsWith('#')) {
        // 我們就關閉整個側邊欄
        body.classList.remove('mobile-menu-open');
        // 瀏覽器會自動處理跳轉到對應區塊
      }
    });
  }

  // --- 3. 漢堡按鈕與遮罩層的開關邏輯 (這部分不變) ---
  const menuToggle = document.getElementById('menu-toggle');
  const overlay = document.getElementById('overlay');

  if (menuToggle && overlay) {
    // 點擊漢堡按鈕時，切換 body 的 class
    menuToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      body.classList.toggle('mobile-menu-open');
    });

    // 點擊遮罩層時，永遠關閉選單
    overlay.addEventListener('click', () => {
      body.classList.remove('mobile-menu-open');
    });
  }

});
</script>
